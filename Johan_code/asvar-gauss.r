# Gaussian kernel on \mathbb{R}^p:
# K(x_1, x_2) = \exp(- \| x_1 - x_2 \|^2 / (2 \sigma^2))
# The parameter `sig` represents \sigma.
# 
# The operator \Phi sends a probability measure P to the function \Phi(P)
# defined by (\Phi(P))(x) = E[K(X, x)] where the random vector X has law P.
#
# The function \Phi(P) is an element of the reproducing kernel Hilbert space (RKHS) generated by K.

# Computes E[K(X_1, X_2)] for independent X_1, X_2
# X_j is p-variate Gaussian with mean \mu_j and variance matrix \Sigma_j
inprH <- function(mu1, Sigma1, mu2, Sigma2, sig) {
  p <- nrow(Sigma1)
  M <- Sigma1 + Sigma2 + sig^2 * diag(p)
  mudiff <- mu1 - mu2
  (sig^p / sqrt(det(M))) * exp(-crossprod(mudiff, solve(M, mudiff))/2) 
}

# test
if (FALSE) { # set to TRUE to run the test
  mu1 <- c(0, 0)
  mu2 <- c(2, 1)
  Sigma1 <- rbind(c(2, 1), c(1, 2))
  Sigma2 <- rbind(c(1, 0), c(0, 1))
  sig <- 0.5
  inprH(mu1, Sigma1, mu2, Sigma2, sig)
}

# Computes \| \Phi(P_1) - \Phi(P_2) \|^2
# = E [ K(X_1, X_1) ] - 2 E[K(X_1, X_2)] + E [K(X_2, X_2)]
# for independent X_1, X_2
# X_j is p-variate Gaussian with mean \mu_j and variance matrix \Sigma_j
nrmH2 <- function(mu1, Sigma1, mu2, Sigma2, sig) {
  inprH(mu1, Sigma1, mu1, Sigma1, sig) - 2 * inprH(mu1, Sigma1, mu2, Sigma2, sig) + inprH(mu2, Sigma2, mu2, Sigma2, sig) 
}

# test
if (FALSE) { # set to TRUE to run the test
  mu1 <- c(0, 0)
  mu2 <- c(2, 1)
  Sigma1 <- rbind(c(2, 1), c(1, 2))
  Sigma2 <- rbind(c(1, 0), c(0, 1))
  sig <- 0.5
  nrmH2(mu1, Sigma1, mu2, Sigma2, sig)
}

# Computes E[ K(X_1, X_2) K(X_1, X_3)] for independent X_1, X_2
# X_j is p-variate Gaussian with mean \mu_j and variance matrix \Sigma_j
cov3kern <- function(mu1, Sigma1, mu2, Sigma2, mu3, Sigma3, sig) {
  p <- nrow(Sigma1)
  p1 <- p+1
  pp <- 2*p
  sig2 <- sig^2
  M <- matrix(0, nrow = pp, ncol = pp)
  M[1:p, 1:p] <- Sigma1 + Sigma2 + sig2 * diag(p)
  M[1:p, p1:pp] <- M[p1:pp, 1:p] <- Sigma1
  M[p1:pp, p1:pp] <- Sigma1 + Sigma3 + sig2 * diag(p)
  mudiff <- c(mu1-mu2, mu1-mu3)
  (sig^pp / sqrt(det(M))) * exp(-crossprod(mudiff, solve(M, mudiff))/2)
}

# test
if (FALSE) { # set to TRUE to run the test
  mu1 <- c(0, 0)
  mu2 <- mu3 <- c(2, 1)
  Sigma1 <- rbind(c(2, 1), c(1, 2))
  Sigma2 <- Sigma3 <- rbind(c(1, 0), c(0, 1))
  sig <- 0.5
  cov3kern(mu1, Sigma1, mu2, Sigma2, mu3, Sigma3, sig)
}

# Computes \operatorname{var}((\Phi_{P_+} - \Phi_{P_-})(X_+))
# with P_+ and P_- p-variate Gaussian
# with means `mu.pl` and `mu.mn`
# and covariance matrices `Sig.pl` and `Sig.mn`
# and X_+ having distribution P_+
varpmp <- function(mu.pl, Sig.pl, mu.mn, Sig.mn, sig) {
  res <- cov3kern(mu.pl, Sig.pl, mu.pl, Sig.pl, mu.pl, Sig.pl, sig)
  res <- res - 2 * cov3kern(mu.pl, Sig.pl, mu.pl, Sig.pl, mu.mn, Sig.mn, sig)
  res <- res + cov3kern(mu.pl, Sig.pl, mu.mn, Sig.mn, mu.mn, Sig.mn, sig)
  res <- res - (inprH(mu.pl, Sig.pl, mu.pl, Sig.pl, sig) - 
                  inprH(mu.pl, Sig.pl, mu.mn, Sig.mn, sig))^2
  return(res)
}

# test
if (FALSE) { # set to TRUE to run the test
  mu.pl <- c(0, 0)
  mu.mn <- c(2, 1)
  Sig.pl <- rbind(c(2, 1), c(1, 2))
  Sig.mn <- rbind(c(1, 0), c(0, 1))
  sig <- 0.5
  varpmp(mu.pl, Sig.pl, mu.mn, Sig.mn, sig)
}

# computes the asymptotic variance of the label shift inner-product based projection estimator 
# for the Gaussian kernel and for Gaussian distributions of features X
# INPUT
# lam.tg, lam.pl, lam.mn : have to do with ratios of sample sizes, see theory or see below
# pi.tg : target probability
# mu.pl, Sig.pl, mu.mn, Sig.mn : parameters of multivariate Gaussian distributions of 'plus' and 'minus' samples
# sig : parameter of the Gaussian kernel function
# OUTPUT
# the asymptotic variance of the estimator
asvar.pi.ipr <- function(lam.tg, lam.pl, lam.mn, 
                         pi.tg, 
                         mu.pl, Sig.pl, mu.mn, Sig.mn,
                         sig) 
{
  Delta2 <- nrmH2(mu.pl, Sig.pl, mu.mn, Sig.mn, sig)^2
  
  n1 <- pi.tg * (lam.tg + lam.pl * pi.tg) 
  n1 <- n1 * varpmp(mu.pl, Sig.pl, mu.mn, Sig.mn, sig)
  
  n2 <- (1 - pi.tg) * (lam.tg + lam.mn * (1 - pi.tg))
  n2 <- n2 * varpmp(mu.mn, Sig.mn, mu.pl, Sig.pl, sig)
  
  n3 <- lam.tg * pi.tg * (1 - pi.tg) * Delta2
  
  numerator <- n1 + n2 + n3
  
  return(numerator/Delta2)
}

# test
if (FALSE) { # set to TRUE to run the test
  # simulation settings
  mu.pl <- c(0, 0)
  Sig.pl <- diag(2)
  mu.mn <- c(2, 1)
  Sig.mn <- rbind(c(2, 1), c(1, 2))
  sig <- 0.5
  n.tg <- 250
  n.pl <- 150
  n.mn <- 200
  pi.tg <- 0.4

  denominator <- 1/n.tg + 1/n.pl + 1/n.mn
  lam.tg <- (1/n.tg) / denominator
  lam.pl <- (1/n.pl) / denominator
  lam.mn <- (1/n.mn) / denominator
  
  # the asymptotic standard deviation of the inner-product based projection estimator
  sqrt(asvar.pi.ipr(lam.tg, lam.pl, lam.mn, pi.tg, mu.pl, Sig.pl, mu.mn, Sig.mn, sig) *
         denominator)
}